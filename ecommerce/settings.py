"""
Django settings for ecommerce project.

Generated by 'django-admin startproject' using Django 1.11.24.

For more information on this file, see
https://docs.djangoproject.com/en/1.11/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.11/ref/settings/
"""

import os

# not using the env file now as we will be running everything off heroku (production) not local. By commenting out import env u then cant run the application locally. To run it uncomment it
import env

import dj_database_url

#  So to actually use our env.py variables, we have to put import env at the top of our settings.py file. And that will import the entire file, and therefore, allow us access to our environmental variables.



# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.11/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# cloud 9 would be: ALLOWED_HOSTS = [os.environ.get('C9_HOSTNAME'), '127.0.0.1']
ALLOWED_HOSTS = [ '127.0.0.1', 'ecommerce-code-institute-2020.herokuapp.com' ]


# Application definition

# So within settings under INSTALLED_APPS, we have to put in django_forms_bootstrap in order for that to work. i had to pip install django-forms-bootstrap 

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django_forms_bootstrap',
    'accounts',
    'products',
    'cart',
    'checkout',
    'storages',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'ecommerce.urls'

#  And because we now have multiple templates folders, we need to specify in our settings that all directories called templates potentially contain templates.

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.media',
                'cart.contexts.cart_contents'
            ],
        },
    },
]

# in the above templates, context_processors are a list of things that are available on every webpage

WSGI_APPLICATION = 'ecommerce.wsgi.application'


# Database
# https://docs.djangoproject.com/en/1.11/ref/settings/#databases



# Yeah that's normal. working in development mode, you have to work on sqlite3 db. But when you go to Heroku, it'll be postgres db so you'll lose all database details and superuser, have to create fresh on postgres. 

# when i migrate the database from dbsqlite(local) to postgres (production) i had a problem migrating when inputting the ususal python manage.py makemigrations. So i was told by a tutor to select option 2 then input 'python manage.py migrate --run-syncdb'


if 'DATABASE_URL' in os.environ:
    DATABASES = {'default': dj_database_url.parse(os.environ.get('DATABASE_URL')) }
else:
    print('Database URL not found. Using SQLite instead')
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }



# Password validation
# https://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# This is something you did in the Django auth app. By adding these in, you should now have login capability.
AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend', 'accounts.backends.CaseInsensitiveAuth'
]

# Internationalization
# https://docs.djangoproject.com/en/1.11/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Then we can make some changes to our settings.py in order to connect to AWS. Static files tend not to change that many things, like CSS, so browsers will often cache them.So the first thing that we're going to add in here is just something to allow boto to know that it can cache the static files.

AWS_S3_OBJECT_PARAMETRES = {
    'Expires': 'Thu, 31 Dec 2099 20:00:00 GMT',
    'CacheControl': 'max-age=94608000',
}
AWS_STORAGE_BUCKET_NAME = 'aleds-ecommerce'
# EU (London) eu-west-2
AWS_S3_REGION_NAME = 'eu-west-2'
AWS_ACCESS_KEY_ID = os.environ.get('AWS_ACCESS_KEY_ID')

AWS_SECRET_ACCESS_KEY = os.environ.get('AWS_SECRET_ACCESS_KEY')

AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

STATICFILES_LOCATION = 'static'
# STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
# instead of the above which we have used until now we will use another value for STATICFILES_STORAGE. This is changed to the following after creating the custom_storages.py file

STATICFILES_STORAGE = 'custom_storages.StaticStorage'

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.11/howto/static-files/

STATIC_URL = '/static/'
# We're going to add in to our settings our STATICFILES_DIRS. And this is just a path to show that any directory called static can contain static files.
STATICFILES_DIRS = ( 
    os.path.join(BASE_DIR, "static"),
    )

MEDIAFILES_LOCATION = 'media'
DEFAULT_FILE_STORAGE = 'custom_storages.MediaStorage'

MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# CODE INSTITUTE found an issue in a video so instead of :MEDIA_URL = '/media/' they tell us to input the following:

MEDIA_URL = "https://%s/%s/" % (AWS_S3_CUSTOM_DOMAIN, MEDIAFILES_LOCATION)


# add in the stripe publishable key
# WE ARE GOING TO create an environment variable called STRIPE_PUBLISHABLE and same for STRIPE_SECRET. The reason we're using environment variables is we don't want these keys, particularly the secret key, to be visible to any of our users. Otherwise, they would be able to hack into our account.
# So OS, by meaning operating system, means whatever computer this is running on. So in this case right now, it's our computer, so we're going to have to create a new file called env.py at the top level of our project. 
STRIPE_PUBLISHABLE = os.getenv('STRIPE_PUBLISHABLE')
STRIPE_SECRET = os.getenv('STRIPE_SECRET')

# Now, this is purely to fix an issue that you have with Cloud9. Dont know what this means
MESSAGE_STORAGE = 'django.contrib.messages.storage.session.SessionStorage'





